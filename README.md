# Sistema Distribu√≠do - Processamento de Tarefas

## Relat√≥rio T√©cnico e Guia de Uso

**Projeto final da disciplina de Sistemas Distribu√≠dos 2025.1**

---

## üöÄ Guia de Instala√ß√£o e Execu√ß√£o

### Pr√©-requisitos

Antes de executar o sistema, certifique-se de ter instalado:

- **Java 21** ou superior
- **Maven 3.8+** para gerenciamento de depend√™ncias
- **Git** para clonagem do reposit√≥rio
- **Sistema Operacional**: Windows, Linux ou macOS

### Verifica√ß√£o dos Pr√©-requisitos

```bash
# Verificar vers√£o do Java
java -version

# Verificar vers√£o do Maven
mvn -version

# Verificar vers√£o do Git
git --version
```

### 1. Clonagem e Prepara√ß√£o

```bash
# Clonar o reposit√≥rio
git clone https://github.com/seu-usuario/sd-processamento-tarefas-projeto-final.git

# Navegar para o diret√≥rio do projeto
cd sd-processamento-tarefas-projeto-final

# Verificar estrutura do projeto
ls -la
```

### 2. Compila√ß√£o do Projeto

```bash
# Limpar e compilar todos os m√≥dulos
mvn clean install

# Verificar se a compila√ß√£o foi bem-sucedida
# Deve exibir "BUILD SUCCESS" para todos os m√≥dulos
```

**Sa√≠da esperada:**

```
[INFO] Reactor Summary for Sistema Distribu√≠do - Processamento de Tarefas 1.0-SNAPSHOT:
[INFO]
[INFO] orchestrator ....................................... SUCCESS
[INFO] client ............................................. SUCCESS
[INFO] worker ............................................. SUCCESS
[INFO] Sistema Distribu√≠do - Processamento de Tarefas ..... SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
```

### 3. Execu√ß√£o dos Componentes

#### 3.1 Executando o Orquestrador Principal

```bash
# Navegar para o m√≥dulo orchestrator
cd orchestrator

# Executar o orquestrador principal
java -cp "target/classes:target/dependency/*" br.edu.ifba.Main

# Ou no Windows:
java -cp "target/classes;target/dependency/*" br.edu.ifba.Main
```

**Sa√≠da esperada:**

```
[INFO] OrquestradorPrincipal iniciado na porta 8080
[INFO] Sistema de heartbeat ativado - intervalo: 5s
[INFO] Aguardando conex√µes de workers e clientes...
```

#### 3.2 Executando Workers

Abra novos terminais para cada worker:

```bash
# Terminal 2 - Worker 1
cd worker
java -cp "target/classes;target/dependency/*" br.edu.ifba.worker.Worker1

# Terminal 3 - Worker 2
java -cp "target/classes;target/dependency/*" br.edu.ifba.worker.Worker2

# Terminal 4 - Worker 3
java -cp "target/classes;target/dependency/*" br.edu.ifba.worker.Worker3
```

**Sa√≠da esperada para cada worker:**

```
[INFO] Worker-001 iniciado
[INFO] Conectando ao orquestrador em localhost:8080
[INFO] Conex√£o estabelecida com sucesso
[INFO] Worker pronto para receber tarefas
```

#### 3.3 Executando Clientes

```bash
# Terminal 5 - Cliente
cd client
java -cp "target/classes;target/dependency/*" br.edu.ifba.Main

# Ou executar clientes espec√≠ficos
java -cp "target/classes;target/dependency/*" br.edu.ifba.client.Cliente1
java -cp "target/classes;target/dependency/*" br.edu.ifba.client.Cliente2
```

### 4. Configura√ß√£o de Rede

#### 4.1 Configura√ß√£o de Portas

O sistema utiliza as seguintes portas por padr√£o:

- **Orquestrador gRPC**: 8080
- **Orquestrador TCP**: 8081
- **Multicast UDP**: 224.0.0.1:8082
- **Workers TCP**: 9001, 9002, 9003

#### 4.2 Configura√ß√£o de Firewall

Certifique-se de que as portas estejam liberadas:

```bash
# Windows (executar como administrador)
netsh advfirewall firewall add rule name="SD-Sistema" dir=in action=allow protocol=TCP localport=8080-8082,9001-9003

# Linux (Ubuntu/Debian)
sudo ufw allow 8080:8082/tcp
sudo ufw allow 9001:9003/tcp
sudo ufw allow 8082/udp
```

### 5. Verifica√ß√£o da Instala√ß√£o

#### 5.1 Teste de Conectividade

```bash
# Verificar se o orquestrador est√° rodando
netstat -an | grep 8080

# Verificar se os workers est√£o conectados
netstat -an | grep 9001
```

#### 5.2 Teste B√°sico do Sistema

```bash
# Executar teste simples
cd client
java -cp "target/classes;target/dependency/*" br.edu.ifba.client.ClienteTeste
```

---

## üí° Exemplos de Uso

### Exemplo 1: Submiss√£o Simples de Tarefa

#### C√≥digo do Cliente:

```java
// Exemplo de submiss√£o de tarefa
public class ExemploCliente {
    public static void main(String[] args) {
        GerenciadorUsuarios gerenciador = new GerenciadorUsuarios();

        // Criar uma tarefa
        Tarefa tarefa = new Tarefa();
        tarefa.setId("TASK-001");
        tarefa.setDescricao("Processar dados de vendas");
        tarefa.setDados("dados_vendas.csv");
        tarefa.setPrioridade(1);

        // Submeter tarefa
        String resultado = gerenciador.submeterTarefa(tarefa);
        System.out.println("Resultado: " + resultado);
    }
}
```

#### Execu√ß√£o:

```bash
cd client
javac -cp "target/classes;target/dependency/*" ExemploCliente.java
java -cp ".:target/classes;target/dependency/*" ExemploCliente
```

#### Sa√≠da esperada:

```
[INFO] Conectando ao orquestrador...
[INFO] Tarefa TASK-001 submetida com sucesso
[INFO] Tarefa atribu√≠da ao Worker-002
[INFO] Processamento conclu√≠do em 2.3s
Resultado: Dados processados com sucesso - 1250 registros analisados
```

### Exemplo 2: Processamento em Lote

#### C√≥digo para m√∫ltiplas tarefas:

```java
public class ProcessamentoLote {
    public static void main(String[] args) {
        GerenciadorUsuarios gerenciador = new GerenciadorUsuarios();
        List<String> resultados = new ArrayList<>();

        // Submeter 10 tarefas em paralelo
        for (int i = 1; i <= 10; i++) {
            Tarefa tarefa = new Tarefa();
            tarefa.setId("BATCH-" + String.format("%03d", i));
            tarefa.setDescricao("Processamento lote item " + i);
            tarefa.setDados("dataset_" + i + ".json");

            String resultado = gerenciador.submeterTarefa(tarefa);
            resultados.add(resultado);

            System.out.println("Tarefa " + i + " submetida");
        }

        // Aguardar conclus√£o de todas as tarefas
        System.out.println("Todas as tarefas foram processadas:");
        resultados.forEach(System.out::println);
    }
}
```

### Exemplo 3: Monitoramento de Sistema

#### C√≥digo para monitorar workers:

```java
public class MonitorSistema {
    public static void main(String[] args) {
        // Conectar ao orquestrador para monitoramento
        OrquestradorClient client = new OrquestradorClient();

        while (true) {
            // Obter status dos workers
            List<StatusWorker> workers = client.obterStatusWorkers();

            System.out.println("=== Status do Sistema ===");
            for (StatusWorker worker : workers) {
                System.out.printf("Worker %s: %s - Carga: %d/%d%n",
                    worker.getId(),
                    worker.getStatus(),
                    worker.getTarefasAtivas(),
                    worker.getCapacidadeMaxima());
            }

            // Aguardar 10 segundos
            Thread.sleep(10000);
        }
    }
}
```

### Exemplo 4: Simula√ß√£o de Falhas

#### Teste de toler√¢ncia a falhas:

```bash
# Terminal 1 - Executar sistema normalmente
cd orchestrator && java -cp "target/classes;target/dependency/*" br.edu.ifba.Main

# Terminal 2 - Executar workers
cd worker && java -cp "target/classes;target/dependency/*" br.edu.ifba.worker.Worker1

# Terminal 3 - Submeter tarefas
cd client && java -cp "target/classes;target/dependency/*" br.edu.ifba.client.ClienteTeste

# Terminal 4 - Simular falha (matar worker)
# Pressionar Ctrl+C no Terminal 2 para simular falha do Worker1

# Observar logs do orquestrador detectando a falha e redistribuindo tarefas
```

### Exemplo 5: Snapshot Global

#### Executar captura de snapshot:

```java
public class ExemploSnapshot {
    public static void main(String[] args) {
        ChandyLamportSnapshot snapshot = new ChandyLamportSnapshot();

        // Iniciar snapshot global
        String snapshotId = snapshot.iniciarSnapshot();
        System.out.println("Snapshot iniciado: " + snapshotId);

        // Aguardar conclus√£o
        while (!snapshot.isSnapshotConcluido(snapshotId)) {
            Thread.sleep(1000);
        }

        // Obter resultado do snapshot
        EstadoGlobal estado = snapshot.obterEstadoGlobal(snapshotId);
        System.out.println("Estado capturado:");
        System.out.println("- Tarefas ativas: " + estado.getTarefasAtivas());
        System.out.println("- Workers ativos: " + estado.getWorkersAtivos());
        System.out.println("- Timestamp Lamport: " + estado.getTimestampLamport());
    }
}
```

### Exemplo 6: Configura√ß√£o Personalizada

#### Arquivo de configura√ß√£o (config.properties):

```properties
# Configura√ß√µes do Orquestrador
orchestrator.port=8080
orchestrator.backup.port=8081
heartbeat.interval=5000
heartbeat.timeout=15000

# Configura√ß√µes de Workers
worker.capacity.default=10
worker.timeout=30000

# Configura√ß√µes de Rede
multicast.address=224.0.0.1
multicast.port=8082

# Configura√ß√µes de Log
log.level=INFO
log.file=sistema-distribuido.log
```

#### Carregamento da configura√ß√£o:

```java
public class SistemaComConfiguracao {
    public static void main(String[] args) {
        // Carregar configura√ß√µes
        Properties config = new Properties();
        config.load(new FileInputStream("config.properties"));

        // Inicializar sistema com configura√ß√µes personalizadas
        OrquestradorPrincipal orchestrator = new OrquestradorPrincipal(config);
        orchestrator.iniciar();
    }
}
```

---

## üîß Solu√ß√£o de Problemas

### Problemas Comuns

#### 1. Erro de Compila√ß√£o

```bash
# Limpar cache do Maven
mvn clean

# Recompilar com debug
mvn clean install -X
```

#### 2. Porta em Uso

```bash
# Verificar processos usando a porta
netstat -ano | findstr :8080

# Matar processo (Windows)
taskkill /PID <PID> /F

# Matar processo (Linux/Mac)
kill -9 <PID>
```

#### 3. Problemas de Conectividade

```bash
# Testar conectividade
telnet localhost 8080

# Verificar firewall
ping localhost
```

#### 4. Problemas de Multicast

```bash
# Verificar suporte a multicast
ping 224.0.0.1

# Configurar interface de rede (Linux)
sudo route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0
```

---

## 1. Introdu√ß√£o e Fundamenta√ß√£o Te√≥rica

### 1.1 Introdu√ß√£o

Este projeto implementa um sistema distribu√≠do para processamento de tarefas baseado em uma arquitetura de microservi√ßos com orquestra√ß√£o centralizada. O sistema foi projetado para demonstrar conceitos fundamentais de sistemas distribu√≠dos, incluindo coordena√ß√£o de processos, toler√¢ncia a falhas, balanceamento de carga e sincroniza√ß√£o distribu√≠da.

### 1.2 Workflows em Sistemas Distribu√≠dos

Um workflow em sistemas distribu√≠dos representa uma sequ√™ncia coordenada de tarefas que s√£o executadas em diferentes n√≥s da rede. No contexto deste projeto, implementamos um workflow de processamento de tarefas que envolve:

- **Submiss√£o de Tarefas**: Clientes submetem tarefas ao orquestrador
- **Distribui√ß√£o**: O orquestrador distribui tarefas para workers dispon√≠veis
- **Execu√ß√£o**: Workers processam as tarefas de forma paralela
- **Coleta de Resultados**: O orquestrador coleta e consolida os resultados
- **Resposta**: Os resultados s√£o retornados aos clientes

### 1.3 Balanceamento de Carga

O balanceamento de carga √© crucial para garantir utiliza√ß√£o eficiente dos recursos e evitar sobrecarga de n√≥s espec√≠ficos. Implementamos estrat√©gias de:

- **Distribui√ß√£o Round-Robin**: Tarefas s√£o distribu√≠das sequencialmente entre workers
- **Monitoramento de Carga**: Acompanhamento da capacidade de processamento de cada worker
- **Redistribui√ß√£o Din√¢mica**: Capacidade de realocar tarefas em caso de falhas

### 1.4 Toler√¢ncia a Falhas

A toler√¢ncia a falhas √© implementada atrav√©s de m√∫ltiplos mecanismos:

- **Detec√ß√£o de Falhas**: Sistema de heartbeat para monitorar a sa√∫de dos n√≥s
- **Recupera√ß√£o Autom√°tica**: Mecanismos de failover para orquestradores backup
- **Replica√ß√£o de Estado**: Sincroniza√ß√£o de estado entre n√≥s para garantir consist√™ncia
- **Timeouts e Retries**: Pol√≠ticas de timeout e reenvio para opera√ß√µes cr√≠ticas

---

## 2. Arquitetura do Sistema

### 2.1 Vis√£o Geral da Arquitetura

O sistema adota uma arquitetura h√≠brida que combina elementos de orquestra√ß√£o centralizada com capacidades de auto-organiza√ß√£o distribu√≠da:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Cliente   ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ   Orquestrador      ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ   Worker    ‚îÇ
‚îÇ             ‚îÇ    ‚îÇ   Principal         ‚îÇ    ‚îÇ             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ                         ‚îÇ
                            ‚ñº                         ‚îÇ
                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
                   ‚îÇ   Orquestrador      ‚îÇ            ‚îÇ
                   ‚îÇ   Backup            ‚îÇ            ‚îÇ
                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
                            ‚îÇ                         ‚îÇ
                            ‚ñº                         ‚ñº
                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                   ‚îÇ   Sistema de        ‚îÇ    ‚îÇ   Worker    ‚îÇ
                   ‚îÇ   Snapshots         ‚îÇ    ‚îÇ   Adicional ‚îÇ
                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2.2 Componentes Principais

#### 2.2.1 M√≥dulo Cliente

- **Responsabilidade**: Interface para submiss√£o de tarefas e recebimento de resultados
- **Tecnologias**: gRPC para comunica√ß√£o, Lamport Clock para ordena√ß√£o
- **Funcionalidades**:
  - Submiss√£o de tarefas via gRPC
  - Gerenciamento de usu√°rios
  - Monitoramento de status de tarefas

#### 2.2.2 M√≥dulo Orquestrador

- **Responsabilidade**: Coordena√ß√£o central do sistema e distribui√ß√£o de tarefas
- **Tecnologias**: gRPC, Multicast UDP, Chandy-Lamport Algorithm
- **Funcionalidades**:
  - Distribui√ß√£o inteligente de tarefas
  - Monitoramento de workers
  - Implementa√ß√£o de snapshots globais
  - Sistema de heartbeat para failover

#### 2.2.3 M√≥dulo Worker

- **Responsabilidade**: Execu√ß√£o de tarefas distribu√≠das
- **Tecnologias**: TCP para comunica√ß√£o, Lamport Clock
- **Funcionalidades**:
  - Processamento paralelo de tarefas
  - Comunica√ß√£o com orquestrador
  - Relat√≥rio de status e capacidade

### 2.3 Justificativas Arquiteturais

#### 2.3.1 Escolha da Arquitetura H√≠brida

A arquitetura h√≠brida foi escolhida para combinar as vantagens de:

- **Orquestra√ß√£o Centralizada**: Simplifica a coordena√ß√£o e garante consist√™ncia
- **Elementos Distribu√≠dos**: Aumenta a toler√¢ncia a falhas e escalabilidade

#### 2.3.2 Separa√ß√£o em M√≥dulos

A modulariza√ß√£o permite:

- **Desenvolvimento Independente**: Equipes podem trabalhar em paralelo
- **Escalabilidade Horizontal**: Cada tipo de n√≥ pode ser escalado independentemente
- **Manutenibilidade**: Facilita atualiza√ß√µes e corre√ß√µes

---

## 3. Protocolos, Algoritmos e Pol√≠ticas

### 3.1 Protocolos de Comunica√ß√£o

#### 3.1.1 gRPC (Google Remote Procedure Call)

**Escolha**: Protocolo principal para comunica√ß√£o cliente-orquestrador
**Justificativa**:

- Performance superior ao REST para comunica√ß√£o interna
- Suporte nativo a streaming bidirecional
- Tipagem forte com Protocol Buffers
- Suporte multiplataforma

#### 3.1.2 TCP (Transmission Control Protocol)

**Escolha**: Comunica√ß√£o orquestrador-worker
**Justificativa**:

- Garantia de entrega e ordem das mensagens
- Controle de fluxo integrado
- Adequado para transfer√™ncia de dados cr√≠ticos

#### 3.1.3 UDP Multicast

**Escolha**: Comunica√ß√£o para snapshots e sincroniza√ß√£o
**Justificativa**:

- Efici√™ncia para comunica√ß√£o um-para-muitos
- Baixa lat√™ncia para mensagens de coordena√ß√£o
- Adequado para algoritmos de consenso distribu√≠do

### 3.2 Algoritmos Implementados

#### 3.2.1 Algoritmo de Chandy-Lamport

**Prop√≥sito**: Captura de snapshots globais consistentes
**Implementa√ß√£o**:

```java
// In√≠cio do snapshot
public void iniciarSnapshot() {
    salvarEstadoLocal();
    enviarMarcadores();
    iniciarGravacaoCanais();
}

// Processamento de marcadores
public void processarMarcador(String origem) {
    if (!snapshotIniciado) {
        iniciarSnapshot();
    }
    pararGravacaoCanal(origem);
}
```

#### 3.2.2 Rel√≥gio de Lamport

**Prop√≥sito**: Ordena√ß√£o causal de eventos distribu√≠dos
**Implementa√ß√£o**:

```java
public synchronized long incrementarTempo() {
    return ++tempoLogico;
}

public synchronized void atualizarTempo(long tempoRecebido) {
    this.tempoLogico = Math.max(this.tempoLogico, tempoRecebido) + 1;
}
```

